//  ЛР 1
// Версия 1: 22 байта
LDA 0x0021
MOV B, A
LDA 0x0020
SUB B
MOV C, A                                                                                          
LDA 0x0023
MOV B, A
LDA 0x0022
SUB B
ADD C
STA 0x0026
HLT

// Версия 2: 15 байт
LXI H, 0x0021
MOV A, M
INX H
SUB M
MOV B, A
INX H
MOV A, M
INX H
SUB M
ADD B
INX H
MOV M, A
HLT

// ЛР 2
// Версия 1: 18 байт
LXI H, 0x0021
MOV A, M
CMA
INX H
ANA M
MOV B, A
INX H
MOV C, M
INX H
MOV A, M
CMA
ANA C
ORA B
INX H
MOV M, A
HLT

 //тестим прогу
х1 = 0000 0010
х2 = 0000 0101     не х2 = 1111 1010

0000 0010
*   1111 1010
---------
0000 0010


х3 = 0000 0111     не х3 = 1111 1000
х4 = 0000 0000     не х4 = 1111 1111

1111 1000
*   1111 1111
---------
1111 1000

итого

0000 0010
+  1111 1000
---------
1111 1010 = FA


---------------------------------------------------

х1 = 0000 0010
х2 = 0000 0101     не х2 = 1111 1010

0000 0010
*   1111 1010
---------
0000 0010


х3 = 0000 0100     не х3 = 1111 1011
х4 = 0000 0000     не х4 = 1111 1111

1111 1011
*   1111 1111
---------
1111 1011

итого

0000 0010
+  1111 1011
---------
1111 1011 = FB

//Закончили тестить 

// ЛР 3  (задача 1)
MVI D, 9       ; счетчик
LXI H, 0x0021        ; начало массива
MOV A, M             ; перекидываем значение первого элемента в акк.
INX H                ; переход к след. элементу массива    (сюда прыгаем 0х0006)
ADD M                ; прибавляем след элем.
DCR D                ; увеличиваем счетчик
JNZ 0x0006           ; если предыдущася арифметическая операция изменила регистр и он все еще не равен 0, то совершаем прыжок к адресу 0х0006 
INX H                ; иначе (если регистр D стал равен 0) переходим к этой команде и смещаемся за последний элемент массива
MOV M, A             ; перекладываем сумму
HLT  


// ЛР 3 (задача 2)   (2-й и третий способ лучше)    (31 байт)
MVI D, 9        ; счетчик 
MVI E, 0x0001        ; номер элемента массива начиная с 1-го 
LXI H, 0x0020        ; первый элем. массива
MOV C, M             ; так как 0000 00001 (индекс 1 элемента) имеет нечетное число единиц, кидаем его значение первого элем. в С (выбор просизволен)
INX H                ; (0x0008) переходим к след. элем. 
INR E                ; увеличиваем номер элемента массива
JPO 0x0013           ; если пред. арифм. операция изменила регистр, что значение имеет нечетное число единиц то прыгаем по адресу 0х0013
MOV A, M             ; иначе  (число единиц четно) переходим к след. операции, перекидываем значение тек. элемента массива в акк. 
ADD B                ; складываем с тек. суммой четн. 
MOV B, A             ; кидаем в регистр четных               
JMP 0x0016           ; перепрыгиваем работу с нечетными 
MOV A, M             ; (0x0013)
ADD C                ; все так же как и с ч.
MOV C, A             ;
DCR D                ; (0x0016) уменьшаем счетчик
JNZ 0x0008           ; если не дошли до 0, прыгаем в начало 
INX H                ; дальше вывод результатов и останов
MOV M, C
INX H
MOV M, B
HLT

// (Способ 2) : 26 байт
LXI H, 0x001B
INR D 			
MOV A, M 
JPO 0x000D           
ADD B
MOV B, A
JMP 0x000F
ADD C			
MOV C, A
MOV A, D			
CPI 0x000A
INX H
JM 0x0003
MOV M, B
INX H
MOV M, C
HLT
---------
////////////
1-неч
2-неч
3-ч
4-неч
5-ч
6-ч
7-неч
8-неч23
9-ч
10-ч
//////////

// (Способ 3)
LXI H, 0x001B
INR D 
MOV A, M 
JPO 0x000D           
ADD B
MOV B, A
JMP 0x000F
ADD C
MOV C, A
MOV A, D
CPI 0x000A
INX H
JM 0x0003
MOV M, B
INX H
MOV M, C
HLT

// Способ 4 (не очень)
LXI H, 0x0030
MVI E,11
BEGIN:
	DCR E
	JZ END
	MOV A,M
	INR C
	JPO ODD
	ADD D
	MOV D,A
	INX H
	JMP BEGIN	
ODD:
	ADD B
	MOV B,A
	INX H
	JMP BEGIN

END: 
	MOV M,D
	INX H
	MOV M,B
	HLT